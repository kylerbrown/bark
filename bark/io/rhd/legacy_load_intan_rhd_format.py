#! /bin/env python
#
# Michael Gibson 17 July 2015
# Kyler Brown December 2016
# 2021 changes by Adrian Foy merged in 2021 by Graham Fetterman

import os
import numpy as np

from bark.io.rhd.read_header import read_header
from bark.io.rhd.get_bytes_per_data_block import get_bytes_per_data_block
from bark.io.rhd.legacy_read_one_data_block import read_one_data_block
from bark.io.rhd.notch_filter import notch_filter
from bark.io.rhd.data_to_result import data_to_result

from . import constants as const

UINT16_BIT_OFFSET = int(2**15)

def read_data(filename,
              no_floats=False,
              digital_io_data_dtype=np.uint):
    """Reads Intan RHD2000 data file generated by evaluation board GUI.

    Data are returned in a dictionary, for future extensibility.

    Args:
        filename (str): file to read data from
        no_floats (bool): whether to expand sampled data outputs (including
                          amplifiers and ADCs) from int16 to float64 (defaults
                          to False, i.e., do the expansion).
        digital_io_data_dtype (numpy dtype): what dtype the digital I/O data is
                                             stored as (default: np.uint)
    Returns:
        dict: all data and metadata in the file
    """

    fid = open(filename, 'rb')
    filesize = os.path.getsize(filename)

    header = read_header(fid)

    if header['notch_filter_frequency'] > 0:
        msg = ('Warning: a notch filter ({}Hz) was applied in the GUI, ' +
               'but has not been applied here.')
        print(msg.format(header['notch_filter_frequency']))

    channel_reporting = [('amplifier', 'num_amplifier_channels'),
                         ('auxiliary input', 'num_aux_input_channels'),
                         ('supply voltage', 'num_supply_voltage_channels'),
                         ('board ADC', 'num_board_adc_channels'),
                         ('board digital input', 'num_board_dig_in_channels'),
                         ('board digital output', 'num_board_dig_out_channels'),
                         ('temperature sensor', 'num_temp_sensor_channels')]
    for channel_name, channel_count_id in channel_reporting:
        print('Found {} {} channel{}.'.format(header[channel_count_id],
                                              channel_name,
                                              plural(header[channel_count_id])))
    print('')

    # Determine how many samples the data file contains.
    bytes_per_block = get_bytes_per_data_block(header)

    # How many data blocks remain in this file?
    data_present = False
    bytes_remaining = filesize - fid.tell()
    if bytes_remaining > 0:
        data_present = True

    if bytes_remaining % bytes_per_block != 0:
        msg = ('Something is wrong with file size: ' +
               'should have a whole number of data blocks')
        raise ValueError(msg)

    num_data_blocks = int(bytes_remaining / bytes_per_block)

    num_samples = header['num_samples_per_data_block']
    num_amplifier_samples = num_samples * num_data_blocks
    num_aux_input_samples = (num_samples // 4) * num_data_blocks
    num_supply_voltage_samples = 1 * num_data_blocks
    num_board_adc_samples = num_samples * num_data_blocks
    num_board_dig_in_samples = num_samples * num_data_blocks
    num_board_dig_out_samples = num_samples * num_data_blocks

    record_time = num_amplifier_samples / header['sample_rate']

    if data_present:
        print('File contains {:0.3f} seconds of data.'.format(record_time),
              'Amplifiers were sampled at',
              '{:0.2f} kHz.'.format(header['sample_rate'] / 1000))
    else:
        print('File contains no data. Amplifiers were sampled at',
              '{:0.2f} kHz.'.format(header['sample_rate'] / 1000))

    if data_present:
        # Pre-allocate memory for data.
        data = {}
        if (header['version']['major'], header['version']['minor']) >= (1, 2):
            time_dtype = const.TIMESTAMP_DTYPE_GE_V1_2
        else:
            time_dtype = const.TIMESTAMP_DTYPE_LE_V1_1
        data['t_amplifier'] = np.zeros(num_amplifier_samples, dtype=time_dtype)

        data['amplifier_data'] = np.zeros([header['num_amplifier_channels'],
                                           num_amplifier_samples],
                                          dtype=const.AMPLIFIER_DTYPE)
        data['aux_input_data'] = np.zeros([header['num_aux_input_channels'],
                                           num_aux_input_samples],
                                          dtype=const.AUXILIARY_DTYPE)
        data['supply_voltage_data'] = np.zeros([header['num_supply_voltage_channels'],
                                                num_supply_voltage_samples],
                                               dtype=const.SUPPLY_DTYPE)
        data['temp_sensor_data'] = np.zeros([header['num_temp_sensor_channels'],
                                             num_supply_voltage_samples],
                                            dtype=const.TEMP_DTYPE)
        data['board_adc_data'] = np.zeros([header['num_board_adc_channels'],
                                           num_board_adc_samples],
                                          dtype=const.ADC_DTYPE)
        data['board_dig_in_data'] = np.zeros([header['num_board_dig_in_channels'],
                                              num_board_dig_in_samples],
                                             dtype=digital_io_data_dtype)
        data['board_dig_in_raw'] = np.zeros(num_board_dig_in_samples,
                                            dtype=const.DIG_IN_DTYPE)
        data['board_dig_out_data'] = np.zeros([header['num_board_dig_out_channels'],
                                               num_board_dig_out_samples],
                                              dtype=digital_io_data_dtype)
        data['board_dig_out_raw'] = np.zeros(num_board_dig_out_samples,
                                             dtype=const.DIG_OUT_DTYPE)

        # Initialize indices used in looping
        indices = {}
        indices['amplifier'] = 0
        indices['aux_input'] = 0
        indices['supply_voltage'] = 0
        indices['board_adc'] = 0
        indices['board_dig_in'] = 0
        indices['board_dig_out'] = 0

        for i in range(num_data_blocks):
            read_one_data_block(data, header, indices, fid)

            # Increment indices
            indices['amplifier'] += num_samples
            indices['aux_input'] += num_samples // 4
            indices['supply_voltage'] += 1
            indices['board_adc'] += num_samples
            indices['board_dig_in'] += num_samples
            indices['board_dig_out'] += num_samples

        # Make sure we have read exactly the right amount of data.
        bytes_remaining = filesize - fid.tell()
        if bytes_remaining != 0:
            raise Exception('Error: End of file not reached.')

    # Close data file.
    fid.close()

    extras = {}  # extra parameters
    if data_present:

        # Extract digital input channels to separate variables.
        for i in range(header['num_board_dig_in_channels']):
            mask = 1 << header['board_dig_in_channels'][i]['native_order']
            masked_bits = np.bitwise_and(data['board_dig_in_raw'], mask)
            data['board_dig_in_data'][i,:] = masked_bits.astype(np.bool)

        # Extract digital output channels to separate variables.
        for i in range(header['num_board_dig_out_channels']):
            mask = 1 << header['board_dig_out_channels'][i]['native_order']
            masked_bits = np.bitwise_and(data['board_dig_out_raw'], mask)
            data['board_dig_out_data'][i,:] = masked_bits.astype(np.bool)

        if no_floats:
            # record the bit voltage scaling level but do not apply to the data
            # converting to floats increases size 4x, which makes a big
            # difference at the terabyte+ level.
            extras['amplifier_bit_microvolts'] = const.AMPLIFIER_BIT_MICROVOLTS
            data['amplifier_data'] = (data['amplifier_data'].astype(np.int32) -
                                      UINT16_BIT_OFFSET).astype(np.int16)
            extras['aux_bit_volts'] = const.AUX_BIT_VOLTS
            extras['supply_bit_volts'] = const.SUPPLY_BIT_VOLTS
            extras['temp_bit_celcius'] = const.TEMP_BIT_CELCIUS

            if header['eval_board_mode'] == 1:
                extras['ADC_input_bit_volts'] = const.ADC_BIT_VOLTS_MODE_1
            elif header['eval_board_mode'] == 13:
                extra['ADC_input_bit_volts'] = const.ADC_BIT_VOLTS_MODE_13
            else:
                extras['ADC_input_bit_volts'] = const.ADC_BIT_VOLTS_MODE_0
            data['board_adc_data'] = (data['board_adc_data'].astype(np.int32) -
                                      UINT16_BIT_OFFSET).astype(np.int16)
        else:
            # Scale voltage levels appropriately.
            offset_amp_data = (data['amplifier_data'].astype(np.int32) -
                               UINT16_BIT_OFFSET)
            data['amplifier_data'] = np.multiply(const.AMPLIFIER_BIT_MICROVOLTS,
                                                 offset_amp_data)  # units of microvolts
            data['aux_input_data'] = np.multiply(const.AUX_BIT_VOLTS,
                                                 data['aux_input_data'])  # units of volts
            data['supply_voltage_data'] = np.multiply(const.SUPPLY_BIT_VOLTS,
                                                      data['supply_voltage_data'])  # units of volts
            if header['eval_board_mode'] == 1:
                offset_adc_data = (data['board_adc_data'].astype(np.int32) -
                                   UINT16_BIT_OFFSET)
                data['board_adc_data'] = np.multiply(const.ADC_BIT_VOLTS_MODE_1,
                                                     offset_adc_data)  # units of volts
            elif header['eval_board_mode'] == 13:
                offset_adc_data = (data['board_adc_data'].astype(np.int32) -
                                   UINT16_BIT_OFFSET)
                data['board_adc_data'] = np.multiply(const.ADC_BIT_VOLTS_MODE_13,
                                                     offset_adc_data) # units of volts
            else:
                data['board_adc_data'] = np.multiply(const.ADC_BIT_VOLTS_MODE_0,
                                                     data['board_adc_data'])  # units of volts
            data['temp_sensor_data'] = np.multiply(const.TEMP_BIT_CELCIUS,
                                                   data['temp_sensor_data'])  # units of degrees C

        # Check for gaps in timestamps.
        num_gaps = np.sum(np.diff(data['t_amplifier']) != 1)
        if num_gaps != 0:
            print('Warning: {} gaps in timestamp data found.'.format(num_gaps),
                  'Time scale will not be uniform!')

        # Scale time steps (units of seconds).
        data['t_amplifier'] = data['t_amplifier'] / header['sample_rate']
        data['t_aux_input'] = data['t_amplifier'][0:len(data['t_amplifier']):4]
        per_block = data['t_amplifier'][0:len(data['t_amplifier']):num_samples]
        data['t_supply_voltage'] = per_block
        data['t_temp_sensor'] = per_block
        data['t_board_adc'] = data['t_amplifier']
        data['t_dig'] = data['t_amplifier']

    else:
        data = []

    # Move variables to result struct.
    result = data_to_result(header, data, data_present)
    result.update(extras)
    return result


def plural(n):
    return '' if n == 1 else 's'
